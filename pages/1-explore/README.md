# Часть 1: подключаем и исследуем плату

Нам нужен компьютер, плата с микроконтроллером и программатор ST-Link.

На компьютер нужно установить Arm GNU Toolchain. Его можно скачать
[тут](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads),
возможно в вашем дистрибутиве уже есть готовые пакеты. У вас должна работать
команда arm-none-eabi-gdb. Также нужно установить st-link
([исходники](https://github.com/stlink-org/stlink)), он тоже есть во многих
репозиториях. Я всё делал на линуксе, но в теории макось и винда тоже должны
подойти.

Программатор у меня - фирменный st-link, выломанный из фирменной платы Nucleo.
Но больше распространены китайские st-link в виде флешки, они тоже довольно
дёшевы.

Программатор нужно подключить к компьютеру и выполнить команду
`st-info --probe`. Он должен отобразить некоторую информацию о программаторе.
Если у вас ошибка, попробуйте `sudo st-info --probe`. Если сработает, значит
проблема с правами, разбирайтесь с udev, ну или работайте от рута.

Плата у меня т.н. blue pill с микроконтроллером STM32F103C8T6. Это дешёвая и
распространённая китайская плата. Насколько мне известно, на базовом уровне
многие микроконтроллеры STM32 работают примерно одинаково, поэтому, надеюсь,
информация будет частично применима и для других плат.

У меня плата после покупки и подключению к компьютеру моргала синим диодом. То
бишь в ней уже была какая-то простейшая прошивка для демонстрации
работоспособности.

Плату к программатору надо подключить тремя проводами: GND, SWCLK, SWDIO. Также
плате нужно питание, лучше всего подать питание четвёртым проводом от
программатора. На плате эти пины расположены с противоположной USB-разъёму
стороне, на программаторе - согласно схемы, всё подписано, тут сложностей быть
не должно.

После того, как плата подключена к программатору, `st-info --probe` должен
показать информацию о плате. Если на этом этапе проблемы, нужно их решить.

Вот что выводит у меня:

```
st-info --probe
Found 1 stlink programmers
  version:    V2J29S18
  serial:     066CFF494849887767255731
  flash:      65536 (pagesize: 1024)
  sram:       20480
  chipid:     0x0410
  descr:      F1xx Medium-density
```

Теперь попробуем подключиться к плате отладчиком. Это самое интересное. Для
этого в одной вкладке терминала запускаем `st-util --connect-under-reset`

Он выведет что-то вроде

```
2023-09-08T17:26:46 WARN common.c: NRST is not connected
2023-09-08T17:26:46 INFO common.c: F1xx Medium-density: 20 KiB SRAM, 64 KiB flash in at least 1 KiB pages.
2023-09-08T17:26:46 INFO gdb-server.c: Listening at *:4242...
```

Что это предупреждение означает, я не знаю, если подключить ногу NRST от
микроконтроллера к программатору, оно не исчезает. Но вроде всё работает,
поэтому будем его игнорировать.

Собственно видно: что st-util запустил TCP-сервер на порту 4242. К этому серверу
будет подключаться gdb.

Во второй вкладке запускаем `arm-none-eabi-gdb` (возможно обычный gdb тоже
подойдёт, я не знаю, честно говоря, в чём отличие):

```
arm-none-eabi-gdb
GNU gdb (Arm GNU Toolchain 12.3.Rel1 (Build arm-12.35)) 13.2.90.20230627-git
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "--host=x86_64-pc-linux-gnu --target=arm-none-eabi".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://bugs.linaro.org/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb)
```

И дальше подключаемся к вышеупомянутому серверу:

```
(gdb) target remote 127.0.0.1:4242
Remote debugging using 127.0.0.1:4242
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x08000130 in ?? ()
```

Итак мы подключились отладчиком к плате. В последней строчке у вас скорей всего
будет другой адрес.

Теперь пару слов про то, как вообще работает этот микроконтроллер. Я, конечно,
буду упускать много деталей, попытаюсь передать суть.

Всё взаимодействие со всеми устройствами ведётся через адресное пространство (и
прерывания) инструкциями чтения и записи памяти. Это 32-битный процессор, т.е.
он может адресовать 4 ГиБ адресного пространства. Конечно памяти у него гораздо
меньше, на моём устройстве 20 КиБ оперативной памяти и 64 КиБ флеш-памяти.
Поэтому адресного пространства хватает и на оперативную память, и на
флеш-память, и на все остальные периферийные устройства. Оперативная память
начинается с адреса `0x2000_0000`, а флеш-память начинается с адреса
`0x0800_0000`. Кроме того у микроконтроллера имеется несколько десятков
периферийных устройств (ЦАП, АЦП, DMA-контролер, таймеры, устройства для
ввода-вывода по различным протоколам и многое другое), каждому из которых
назначены свои участки адресного пространства, через которые идёт взаимодействие
с соответсвующим устройством.

В дальнейшем я буду вольно обращаться с термином "память", обозначая им где-то
адресное пространство, где-то оперативную память, где-то флеш память, из
контекста должно быть понятно.

Итак мы подали питание. У микроконтроллера есть два пина BOOT0 и BOOT1. На плате
они настраиваются двумя перемычками. Есть три варианта загрузки, нас интересует
загрузка из флеш-памяти. Для этого нужно выставить BOOT0 в `0` (т.е. соединить с
«землёй»), на моей плате этому соответствует положение перемычки ближе к
USB-порту. Посмотреть больше информации про это можно в Reference Manual, раздел
3.4. В зависимости от выбранной конфигурации процессор делает доступным
выбранное устройство загрузки по адресу `0x0000_0000`. Иными словами, когда мы
грузимся с флеш-памяти, то адрес `0x0800_0000` (а также последующие адреса
флеш-памяти) становится доступным и по адресу `0x0000_0000` . Далее процессор
читает по адресу `0x0000_0000` 4 байта и присваивает это значение регистру sp
(stack pointer, вершина стека). Далее процессор читает по адресу `0x0000_0004` 4
байта и присваивает это значение регистру pc (program counter), иными словами
делает переход по указанному адресу. Ну и, собственно, начинает работу. Читает
инструкцию, выполняет и тд.

Помимо этого у процессора есть возможность его отладки. Собственно что мы и
сделали, подключив к нему программатор. В этом режиме он после инициализации
ничего не начинает выполнять, а ждёт команды от отладчика. Кроме того отладчик
может читать значения всех регистров, любого адреса оперативной памяти и тд.

Собственно для начала прочитаем по 8 байтов по адресам `0x0000_0000` и
`0x0800_0000`, убедимся, что они действительно совпадают, а также попробуем
понять их смысл.

```
(gdb) x/2z 0x00000000
0x0:	0x20004ffc	0x08000131
(gdb) x/2z 0x08000000
0x8000000:	0x20004ffc	0x08000131
```

Команда `x` (от слова eXamine) читает значения из памяти по указанному адресу.
Суффикс `/2z` говорит о том, что мы хотим прочитать 2 слова (т.е. 4-байтовых
значения) и напечатать их в 16-ричном формате.

Как видно, по обоим адресам действительно лежат одинаковые данные. Иными
словами, если верить описанию выше, то после инициализации регистру sp должно
было присвоиться значение `0x2000_4ffc`, а регистру pc значение `0x0800_0131`.
Сейчас мы этом проверим, а пока попробуем чуть-чуть похулиганить. На моей плате
64 кибибайта флеша, поэтому попробуем прочитать пару слов в самом конце.

```
(gdb) x/2z 0x08000000 + 64 * 1024 - 4
0x800fffc:	0xffffffff	Cannot access memory at address 0x8010000
(gdb)
```

Собственно как и ожидалось: последнее слово ещё что-то содержит, а после него
уже адреса недоступны для чтения. Поэтому командой x можно исследовать что
угодно безо всяких опасений.

Теперь проверим значения регистров:

```
(gdb) print/z $sp
$1 = 0x20004ffc
(gdb) print/z $pc
$2 = 0x08000130
```

Для чтения значений используется команда `print`. Регистры доступны через
синтаксис `$sp`, `$pc`, `$r0` и тд. Также все регистры можно посмотреть командой
`info registers`. Важно понимать разницу между `print $sp` и `x $s`p. Первая
команда печатает значение регистра, вторая команда значение регистра
интерпретирует, как адрес и печатает значение из памяти.

Со значением регистра `$sp` всё ожидаемо - он действительно загрузился из адреса
`0x0000_0000`, а вот `$pc` оказался на единицу меньше. Тут можно много
рассказывать, но это всё не очень интересно - просто запомните, что в
архитектуре arm cortex адреса инструкций всегда чётные, при этом значения
указателей иногда нечётные. Собственно адрес `0x0000_0004`, с которого начнётся
выполнение, должен быть нечётным, при этом младший бит обнулится перед
переходом. Также инструкции перехода `BX`, `BLX` требуют то же самое: младший
бит адреса, на который выполняется переход, должен быть равен единице, но при
этом переход делается на адрес с нулевым младшим битом. А команды `B` и `BL` не
требуют, вот такая особенность.

В итоге процессор перешёл на адрес `0x0800_0130` и остановился в ожидании команд
от отладчика. На вашей плате скорей всего все эти значения будут немного
другими, я «заводскую» прошивку стёр, но принцип ровно тот же. На всякий случай
напомню, что по адресу `0x0800_0130` у нас доступна флеш-память, т.е. это код из
флеш-памяти.

Теперь можно попробовать дизассемблировать инструкцию, которая сейчас будет
выполняться:

```
(gdb) x/i $pc
=> 0x8000130:	add.w	r0, r0, #1
```

Как видно, для дизассемблирования используется та же команда `x`. Только вместо
`/z` используется формат `/i`. `z` это шестнадцатеричный формат, `i` это
интерпретация числа, как инструкции. Для интереса покажу ещё несколько форматов,
думаю, всё и так очевидно.

```
(gdb) x/z $pc
0x8000130:	0x0001f100
(gdb) x/d $pc
0x8000130:	127232
(gdb) x/x $pc
0x8000130:	0x0001f100
(gdb) x/t $pc
0x8000130:	00000000000000011111000100000000
```

Форматы `/z` и `/x` означают одно и то же, но в некоторых случаях `/x` не
добавляет нули слева, а `/z` всегда добавляет нули.

Иными словами 4 байта `01 00 f1 00` процессором интерпретируются, как команда
`add.w r0, r0, #1`. Эта команда аналогична псевдокоду `r0 := r0 + 1`.

Важно понимать, что эта команда ещё не выполнена, процессор только готовится её
выполнить.

Теперь распечатаем значение регистра `r0`, далее выполним команду и распечатаем
значение регистра ещё раз.

```
(gdb) p/z $r0
$6 = 0x48b503b6
(gdb) stepi
0x08000134 in ?? ()
(gdb) p/z $r0
$7 = 0x48b503b7
```

Как видно, в регистре `r0` было какое-то непонятное значение и процессор
действительно увеличил это значение в регистре `r0` на единицу. После команды
`stepi` процессор перешёл на 4 байта вперёд и готовится выполнить следующую
команду. Посмотрим, что там за команда.

```
x/i $pc
=> 0x8000134:	b.w	0x8000130
```

Это команда branch, команда безусловного перехода по указанному адресу. Если её
выполнить, то процессор вернётся на предыдущую инструкцию. Так и будет туда-сюда
прыгать, считая от 0 до 4 миллиардов по кругу, пока не выключим питание или не
нажмём кнопку reset.

В псевдокоде эта программа выглядит примерно так:

```
loop: r0 := r0 + 1;
goto loop;
```

В дальнейшем программы на языке ассемблера будут иллюстрироваться псевдоком.

На вашей плате из магазина программа будет другая. Но принципы работы те же.

На этом первая часть закончена. Мы запустили плату, подключились к ней и
убедились, что там внутри действительно процессор, а не неонка.
